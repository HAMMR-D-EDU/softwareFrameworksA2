import express from 'express';
import { getCollection, getNextId } from '../config/db.js';

const router = express.Router();

// GET /api/groups
router.get('/', async (req, res) => {
  try {
    const groupsCollection = getCollection('groups');
    const groups = await groupsCollection.find({}).toArray();
    res.json(groups.map(({ _id, ...group }) => group));
  } catch (error) {
    console.error('Get groups error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// POST /api/groups
router.post('/', async (req, res) => {
  try {
    const { name, creatorId } = req.body || {};
    
    if (!name || !creatorId) {
      return res.status(400).json({ ok: false, msg: 'Missing fields' });
    }
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    
    // Check if group name already exists
    const existingGroup = await groupsCollection.findOne({ name });
    if (existingGroup) {
      return res.status(409).json({ ok: false, msg: 'Group name exists' });
    }
    
    // Verify creator exists and has permissions
    const creator = await usersCollection.findOne({ id: creatorId });
    if (!creator) {
      return res.status(404).json({ ok: false, msg: 'Creator not found' });
    }
    
    const isGroupAdmin = creator.roles.includes('groupAdmin') || creator.roles.includes('group_admin');
    const isSuperAdmin = creator.roles.includes('super') || creator.roles.includes('super_admin');
    
    if (!isGroupAdmin && !isSuperAdmin) {
      return res.status(403).json({ ok: false, msg: 'Only group admins can create groups' });
    }
    
    // Generate group ID
    const id = await getNextId('groups', 'g_');
    
    // Create new group with creator as first member/admin
    const memberIds = [creatorId];
    const adminIds = [creatorId];
    
    // Add all super admins to the group
    const superAdmins = await usersCollection.find({
      $or: [
        { roles: 'super' },
        { roles: 'super_admin' }
      ]
    }).toArray();
    
    superAdmins.forEach(sa => {
      if (!memberIds.includes(sa.id)) memberIds.push(sa.id);
      if (!adminIds.includes(sa.id)) adminIds.push(sa.id);
    });
    
    const newGroup = {
      id,
      name,
      ownerId: creatorId,
      creatorId,
      memberIds,
      adminIds
    };
    
    await groupsCollection.insertOne(newGroup);
    
    const { _id, ...groupResponse } = newGroup;
    res.status(201).json(groupResponse);
  } catch (error) {
    console.error('Create group error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// DELETE /api/groups/:groupId
router.delete('/:groupId', async (req, res) => {
  try {
    const { groupId } = req.params;
    const { adminId } = req.body || {};
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    const channelsCollection = getCollection('channels');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Verify admin permissions
    const admin = await usersCollection.findOne({ id: adminId });
    if (!admin) {
      return res.status(403).json({ ok: false, msg: 'Admin not found' });
    }
    
    const isSuperAdmin = admin.roles.includes('super') || admin.roles.includes('super_admin');
    if (!isSuperAdmin && group.ownerId !== adminId) {
      return res.status(403).json({ ok: false, msg: 'Only group owner or super admin can delete group' });
    }
    
    // Delete all channels in this group
    await channelsCollection.deleteMany({ groupId });
    
    // Delete the group
    await groupsCollection.deleteOne({ id: groupId });
    
    res.json({ ok: true, msg: 'Group and all its channels removed successfully' });
  } catch (error) {
    console.error('Delete group error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// POST /api/groups/:groupId/members
router.post('/:groupId/members', async (req, res) => {
  try {
    const { groupId } = req.params;
    const { userId, adminId } = req.body || {};
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Verify admin permissions
    const admin = await usersCollection.findOne({ id: adminId });
    if (!admin) {
      return res.status(403).json({ ok: false, msg: 'Admin not found' });
    }
    
    if (!admin.roles.includes('super') && !group.adminIds.includes(adminId)) {
      return res.status(403).json({ ok: false, msg: 'Only group admins can add members' });
    }
    
    // Check if user is already a member
    if (group.memberIds.includes(userId)) {
      return res.status(409).json({ ok: false, msg: 'User is already a member' });
    }
    
    // Add user to group
    await groupsCollection.updateOne(
      { id: groupId },
      { $addToSet: { memberIds: userId } }
    );
    
    res.json({ ok: true, msg: 'User added to group' });
  } catch (error) {
    console.error('Add member error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// DELETE /api/groups/:groupId/members/:userId
router.delete('/:groupId/members/:userId', async (req, res) => {
  try {
    const { groupId, userId } = req.params;
    const { adminId } = req.body || {};
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    const channelsCollection = getCollection('channels');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Verify admin permissions
    const admin = await usersCollection.findOne({ id: adminId });
    if (!admin) {
      return res.status(403).json({ ok: false, msg: 'Admin not found' });
    }
    
    const isAdminSuper = admin.roles.includes('super') || admin.roles.includes('super_admin');
    
    if (!isAdminSuper && !group.adminIds.includes(adminId)) {
      return res.status(403).json({ ok: false, msg: 'Only group admin or super admin can remove users' });
    }
    
    // Check if user is a member
    if (!group.memberIds.includes(userId)) {
      return res.status(400).json({ ok: false, msg: 'User is not a member of this group' });
    }
    
    // Check if target is super admin
    const targetUser = await usersCollection.findOne({ id: userId });
    const isTargetSuper = targetUser && (targetUser.roles.includes('super') || targetUser.roles.includes('super_admin'));
    
    if (isTargetSuper && !isAdminSuper) {
      return res.status(403).json({ ok: false, msg: 'Group admins cannot remove super admins from groups' });
    }
    
    // Remove user from group
    await groupsCollection.updateOne(
      { id: groupId },
      {
        $pull: {
          memberIds: userId,
          adminIds: userId
        }
      }
    );
    
    // Remove user from all channels in this group
    await channelsCollection.updateMany(
      { groupId },
      {
        $pull: {
          bannedUserIds: userId,
          memberIds: userId
        }
      }
    );
    
    res.json({ ok: true, msg: 'User removed from group successfully' });
  } catch (error) {
    console.error('Remove member error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// POST /api/groups/:groupId/promote
router.post('/:groupId/promote', async (req, res) => {
  try {
    const { groupId } = req.params;
    const { userId, promoterId } = req.body || {};
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Verify promoter permissions
    const promoter = await usersCollection.findOne({ id: promoterId });
    if (!promoter) {
      return res.status(404).json({ ok: false, msg: 'Promoter not found' });
    }
    
    const isSuperAdmin = promoter.roles.includes('super');
    const isGroupAdmin = group.adminIds.includes(promoterId);
    
    if (!isSuperAdmin && !isGroupAdmin) {
      return res.status(403).json({ ok: false, msg: 'Only super admins or group admins can promote users' });
    }
    
    // Find user to promote
    const user = await usersCollection.findOne({ id: userId });
    if (!user) {
      return res.status(404).json({ ok: false, msg: 'User not found' });
    }
    
    // Check if user is a member
    if (!group.memberIds.includes(userId)) {
      return res.status(400).json({ ok: false, msg: 'User is not a member of this group' });
    }
    
    // Check if already admin
    if (group.adminIds.includes(userId)) {
      return res.status(400).json({ ok: false, msg: 'User is already a group admin' });
    }
    
    // Add groupAdmin role to user if not present
    if (!user.roles.includes('groupAdmin')) {
      await usersCollection.updateOne(
        { id: userId },
        { $addToSet: { roles: 'groupAdmin' } }
      );
    }
    
    // Add user to group admins
    await groupsCollection.updateOne(
      { id: groupId },
      { $addToSet: { adminIds: userId } }
    );
    
    res.json({ ok: true, msg: 'User promoted to group admin' });
  } catch (error) {
    console.error('Promote user error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// POST /api/groups/:groupId/interest
router.post('/:groupId/interest', async (req, res) => {
  try {
    const { groupId } = req.params;
    const { userId } = req.body || {};
    
    const groupsCollection = getCollection('groups');
    const groupInterestsCollection = getCollection('groupInterests');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Check if user is already a member
    if (group.memberIds.includes(userId)) {
      return res.status(409).json({ ok: false, msg: 'User is already a member of this group' });
    }
    
    // Check if interest already registered
    const existingInterest = await groupInterestsCollection.findOne({ groupId, userId });
    if (existingInterest) {
      return res.status(409).json({ ok: false, msg: 'Interest already registered' });
    }
    
    // Create interest
    const id = await getNextId('groupInterests', 'i_');
    const newInterest = {
      id,
      groupId,
      userId,
      timestamp: new Date().toISOString()
    };
    
    await groupInterestsCollection.insertOne(newInterest);
    
    res.json({ ok: true, msg: 'Interest registered. Group admin will review your request.' });
  } catch (error) {
    console.error('Register interest error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// GET /api/groups/:groupId/interests
router.get('/:groupId/interests', async (req, res) => {
  try {
    const { groupId } = req.params;
    const groupInterestsCollection = getCollection('groupInterests');
    
    const interests = await groupInterestsCollection.find({ groupId }).toArray();
    res.json(interests.map(({ _id, ...interest }) => interest));
  } catch (error) {
    console.error('Get interests error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// POST /api/groups/:groupId/interests/:interestId/approve
router.post('/:groupId/interests/:interestId/approve', async (req, res) => {
  try {
    const { groupId, interestId } = req.params;
    const { adminId } = req.body || {};
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    const groupInterestsCollection = getCollection('groupInterests');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Verify admin permissions
    const admin = await usersCollection.findOne({ id: adminId });
    if (!admin) {
      return res.status(403).json({ ok: false, msg: 'Admin not found' });
    }
    
    if (!admin.roles.includes('super') && !group.adminIds.includes(adminId)) {
      return res.status(403).json({ ok: false, msg: 'Only group admins can approve requests' });
    }
    
    // Find interest
    const interest = await groupInterestsCollection.findOne({ id: interestId, groupId });
    if (!interest) {
      return res.status(404).json({ ok: false, msg: 'Interest not found' });
    }
    
    // Check if user is already a member
    if (group.memberIds.includes(interest.userId)) {
      await groupInterestsCollection.deleteOne({ id: interestId });
      return res.json({ ok: true, msg: 'User already a member; request removed' });
    }
    
    // Add user to group members
    await groupsCollection.updateOne(
      { id: groupId },
      { $addToSet: { memberIds: interest.userId } }
    );
    
    // If user is a group admin, add to adminIds
    const addedUser = await usersCollection.findOne({ id: interest.userId });
    if (addedUser && (addedUser.roles.includes('group_admin') || addedUser.roles.includes('groupAdmin'))) {
      await groupsCollection.updateOne(
        { id: groupId },
        { $addToSet: { adminIds: interest.userId } }
      );
    }
    
    // Remove the interest request
    await groupInterestsCollection.deleteOne({ id: interestId });
    
    res.json({ ok: true, msg: 'User added to group' });
  } catch (error) {
    console.error('Approve interest error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// DELETE /api/groups/:groupId/interests/:interestId
router.delete('/:groupId/interests/:interestId', async (req, res) => {
  try {
    const { groupId, interestId } = req.params;
    const { adminId } = req.body || {};
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    const groupInterestsCollection = getCollection('groupInterests');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Verify admin permissions
    const admin = await usersCollection.findOne({ id: adminId });
    if (!admin) {
      return res.status(403).json({ ok: false, msg: 'Admin not found' });
    }
    
    if (!admin.roles.includes('super') && !group.adminIds.includes(adminId)) {
      return res.status(403).json({ ok: false, msg: 'Only group admins can reject requests' });
    }
    
    // Find and delete interest
    const interest = await groupInterestsCollection.findOne({ id: interestId, groupId });
    if (!interest) {
      return res.status(404).json({ ok: false, msg: 'Interest not found' });
    }
    
    await groupInterestsCollection.deleteOne({ id: interestId });
    
    res.json({ ok: true, msg: 'Request rejected' });
  } catch (error) {
    console.error('Reject interest error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// GET /api/groups/:groupId/members
router.get('/:groupId/members', async (req, res) => {
  try {
    const { groupId } = req.params;
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Get all members
    const members = await usersCollection.find({
      id: { $in: group.memberIds }
    }).toArray();
    
    // Remove passwords and MongoDB _id
    const safeMembers = members.map(({ password, _id, ...safe }) => safe);
    res.json(safeMembers);
  } catch (error) {
    console.error('Get members error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// GET /api/groups/:groupId/channels
router.get('/:groupId/channels', async (req, res) => {
  try {
    const { groupId } = req.params;
    const { userId } = req.query;
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    const channelsCollection = getCollection('channels');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Check user permissions
    const requester = await usersCollection.findOne({ id: userId });
    const isSuperAdmin = requester && (requester.roles.includes('super') || requester.roles.includes('super_admin'));
    const isGroupAdmin = group.adminIds.includes(userId);
    
    // Get channels
    let query = { groupId };
    if (!isSuperAdmin && !isGroupAdmin) {
      // Regular users only see channels they're members of
      query.memberIds = userId;
    }
    
    const channels = await channelsCollection.find(query).toArray();
    res.json(channels.map(({ _id, ...channel }) => channel));
  } catch (error) {
    console.error('Get group channels error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// POST /api/groups/:groupId/channels
router.post('/:groupId/channels', async (req, res) => {
  try {
    const { groupId } = req.params;
    const { name, creatorId } = req.body || {};
    
    if (!name || !creatorId) {
      return res.status(400).json({ ok: false, msg: 'Missing fields' });
    }
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    const channelsCollection = getCollection('channels');
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Verify creator permissions
    const creator = await usersCollection.findOne({ id: creatorId });
    const isSuperAdmin = creator && (creator.roles.includes('super') || creator.roles.includes('super_admin'));
    const isGroupAdmin = group.adminIds.includes(creatorId);
    
    if (!isSuperAdmin && !isGroupAdmin) {
      return res.status(403).json({ ok: false, msg: 'Only group admins can create channels' });
    }
    
    // Check if channel name exists in this group
    const existingChannel = await channelsCollection.findOne({ groupId, name });
    if (existingChannel) {
      return res.status(409).json({ ok: false, msg: 'Channel name exists in this group' });
    }
    
    // Generate channel ID
    const id = await getNextId('channels', 'c_');
    
    // Create member list (creator + group owner + super admins)
    const memberIds = [creatorId];
    if (!memberIds.includes(group.ownerId)) {
      memberIds.push(group.ownerId);
    }
    
    // Add all super admins
    const superAdmins = await usersCollection.find({
      $or: [
        { roles: 'super' },
        { roles: 'super_admin' }
      ]
    }).toArray();
    
    superAdmins.forEach(sa => {
      if (!memberIds.includes(sa.id)) memberIds.push(sa.id);
    });
    
    const newChannel = {
      id,
      name,
      groupId,
      creatorId,
      bannedUserIds: [],
      memberIds
    };
    
    await channelsCollection.insertOne(newChannel);
    
    const { _id, ...channelResponse } = newChannel;
    res.status(201).json(channelResponse);
  } catch (error) {
    console.error('Create channel error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

// DELETE /api/groups/:groupId/channels/:channelId
router.delete('/:groupId/channels/:channelId', async (req, res) => {
  try {
    const { groupId, channelId } = req.params;
    const { adminId } = req.body || {};
    
    const groupsCollection = getCollection('groups');
    const usersCollection = getCollection('users');
    const channelsCollection = getCollection('channels');
    
    // Find channel
    const channel = await channelsCollection.findOne({ id: channelId, groupId });
    if (!channel) {
      return res.status(404).json({ ok: false, msg: 'Channel not found' });
    }
    
    // Find group
    const group = await groupsCollection.findOne({ id: groupId });
    if (!group) {
      return res.status(404).json({ ok: false, msg: 'Group not found' });
    }
    
    // Verify admin permissions
    const admin = await usersCollection.findOne({ id: adminId });
    if (!admin) {
      return res.status(403).json({ ok: false, msg: 'Admin not found' });
    }
    
    const isSuperAdmin = admin.roles.includes('super') || admin.roles.includes('super_admin');
    if (!isSuperAdmin && !group.adminIds.includes(adminId)) {
      return res.status(403).json({ ok: false, msg: 'Only group admin or super admin can delete channel' });
    }
    
    // Delete channel
    await channelsCollection.deleteOne({ id: channelId, groupId });
    
    res.json({ ok: true, msg: 'Channel removed successfully' });
  } catch (error) {
    console.error('Delete channel error:', error);
    res.status(500).json({ ok: false, msg: 'Internal server error' });
  }
});

export default router;
